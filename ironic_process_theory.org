#+OPTIONS: toc:nil
#+OPTIONS: num:nil
* Ironic Process Theory
This is going to be part 1 of what I hope will be a multi-part series. I originally wanted to write one blog post but after spending two weeks working on it, I've realize it's much larger than a single post. To accomplish what I want is going take multiple posts. I'm hoping that each post will build on the previous posts and by the end it will all come together.
 
According to Wikipedia, Ironic Process Theory "refers to the psychological process whereby deliberate attempts to suppress certain thoughts make them more likely to surface". In 1863 Fyodor Dostevsky wrote "Try to pose for yourself this task: not to think of a polar bear, and you will see that the cursed thing will come to mind every minute". Go ahead and try to think of anything else other than a polar bear for 5 minutes. You'll quickly find that it's impossible and a polar bear keeps popping into your head. It's of interest to me because we run into something very similar to it so frequently.
I recently went through something similar while working on my listening skills.
 
When I'm working on a problem, I will be distracted. Especially while listening to others. Most of the time, the others is my wife. If you've been in any significant relationship, you know this isn't an ideal situation. Significant others will notice when you aren't fully listening. I was trying to actively listen to my wife and avoid interrupting her. While working on this I kept telling myself to listen and to ask leading questions so I could better understand her. It didn't work. I was actually listening less. I spent so much time telling myself to focus and ask questions that I caught less of my wife's meaning and ended up drawing the wrong conclusions. She ended up telling me that she felt like I wasn't listening to her and I had to take corrective action.
 
 In software development, we may be trying to make a design more flexible by adding layers of abstractions only to find out later that our abstraction makes it very difficult to solve certain problems. I've seen well meaning engineers trying to make things easier for everyone creating services. They spent about nine months creating a framework that was modular and allowed users to swap out implementations at runtime. It worked great for the engineers that designed it. Anytime they needed to create a new service, it took them a few minutes to have it up and running and they spent the rest of the time focused on writing the business logic. When other engineers attempted to implement a new service with the framework, it slowed things down. They would run into bugs, sometimes difficult to troubleshoot bugs that the authors avoided because they knew better. The authors felt that the framework was intuitive so they avoided writing documentation for it. The company eventually scrapped the framework after a couple of years because the cost in complexity offset any savings they were trying to achieve.
 
One case from my the early days of my career, I spent several days refactoring code that was used in a reporting layer to make it much faster. In engineering speak, I changed our data structures from using hashmaps to sets. The improvement in speed was significant for reporting, but near the end of the work I found that I had made some key use cases so bad that I had to scrap all my work and start over.
 
I even had a friend that tried to save money by not getting maintenance performed on his car. He thought the cost of oil changes and belt changes would make it worthwhile in the long run. His engine froze up on him a couple of years after purchasing a new car and he ended up having to buy a new one while still paying off his loan on the old one.
 
Anytime we try to change something, we may bring about the opposite effect.
